import{r as e,a as i,R as t}from"./react-vendor-DtX1tuCI.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))i(e);new MutationObserver(e=>{for(const t of e)if("childList"===t.type)for(const e of t.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&i(e)}).observe(document,{childList:!0,subtree:!0})}function i(e){if(e.ep)return;e.ep=!0;const i=function(e){const i={};return e.integrity&&(i.integrity=e.integrity),e.referrerPolicy&&(i.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?i.credentials="include":"anonymous"===e.crossOrigin?i.credentials="omit":i.credentials="same-origin",i}(e);fetch(e.href,i)}}();var a={exports:{}},s={},n=e,l=Symbol.for("react.element"),o=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,c=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,d={key:!0,ref:!0,__self:!0,__source:!0};function u(e,i,t){var a,s={},n=null,o=null;for(a in void 0!==t&&(n=""+t),void 0!==i.key&&(n=""+i.key),void 0!==i.ref&&(o=i.ref),i)r.call(i,a)&&!d.hasOwnProperty(a)&&(s[a]=i[a]);if(e&&e.defaultProps)for(a in i=e.defaultProps)void 0===s[a]&&(s[a]=i[a]);return{$$typeof:l,type:e,key:n,ref:o,props:s,_owner:c.current}}s.Fragment=o,s.jsx=u,s.jsxs=u,a.exports=s;var p,m,h,v,f=a.exports,x={},y=i;x.createRoot=y.createRoot,x.hydrateRoot=y.hydrateRoot,(m=p||(p={})).NUMBER="NUMBER",m.IDENTIFIER="IDENTIFIER",m.TYPE_BOUND="TYPE_BOUND",m.PLUS="PLUS",m.MINUS="MINUS",m.MULTIPLY="MULTIPLY",m.DIVIDE="DIVIDE",m.POWER="POWER",m.LPAREN="LPAREN",m.RPAREN="RPAREN",m.EOF="EOF",(v=h||(h={})).NUMBER_LITERAL="NUMBER_LITERAL",v.TYPE_BOUND_LITERAL="TYPE_BOUND_LITERAL",v.IDENTIFIER="IDENTIFIER",v.BINARY_OP="BINARY_OP",v.EXPONENTIATION="EXPONENTIATION";class g extends Error{constructor(e){super(e),this.name="SolCalcError"}}class b extends g{constructor(e,i){super(e),this.position=i,this.name="ParseError"}}class w extends g{constructor(e){super(e),this.name="EvaluationError"}}class N extends w{constructor(e,i,t){super(`Decimal mismatch in ${t}: left has ${e} decimals, right has ${i} decimals. Addition and subtraction require matching decimals.`),this.leftDecimals=e,this.rightDecimals=i,this.operator=t,this.name="DecimalMismatchError"}}class S extends w{constructor(e){super(`Invalid exponentiation: ${e}. Only \`10 ** n\` with dimensionless integer n is supported.`),this.name="InvalidExponentiationError"}}class k extends w{constructor(){super("Division by zero"),this.name="DivisionByZeroError"}}class E extends w{constructor(e){super(`Variable "${e}" is not defined. All variables must have explicit values and decimals.`),this.variableName=e,this.name="UndefinedVariableError"}}class R extends w{constructor(e){super(`Variable "${e}" is missing decimals. All variables must have explicit decimals >= 0.`),this.variableName=e,this.name="MissingDecimalsError"}}function I(e){const i=[];let t=0;for(;t<e.length;){const a=e[t];if(D(a))t++;else{if("t"===a&&"type("===e.substring(t,t+5)){const a=T(e,t);if(a){i.push(a.token),t=a.endPosition;continue}}if(A(a)){const a=C(e,t);i.push(a),t=a.position+a.value.length;continue}if(L(a)){const a=j(e,t);i.push(a),t=a.position+a.value.length;continue}switch(a){case"+":i.push({type:p.PLUS,value:"+",position:t}),t++;continue;case"-":i.push({type:p.MINUS,value:"-",position:t}),t++;continue;case"/":i.push({type:p.DIVIDE,value:"/",position:t}),t++;continue;case"(":i.push({type:p.LPAREN,value:"(",position:t}),t++;continue;case")":i.push({type:p.RPAREN,value:")",position:t}),t++;continue;case"*":"*"===e[t+1]?(i.push({type:p.POWER,value:"**",position:t}),t+=2):(i.push({type:p.MULTIPLY,value:"*",position:t}),t++);continue;case".":const s=i[i.length-1],n=e[t+1];if(s&&s.type===p.NUMBER||n&&A(n))throw new b("Decimal literals are not supported in Solidity.\n\nSolidity does not allow floating-point values (e.g., 8.5, 0.1, 3.14).\nUse scaled integers instead:\n  • 8.5 → 85 * 1e17\n  • 0.25 → 25 * 1e16\n  • 8.5 / 2 → (85 * 1e17) / 2",t);throw new b(`Unexpected character: '${a}'`,t);default:throw new b(`Unexpected character: '${a}'`,t)}}}return i.push({type:p.EOF,value:"",position:t}),i}function C(e,i){let t=i,a="";for(;t<e.length&&A(e[t]);)a+=e[t],t++;if(t<e.length&&("e"===e[t]||"E"===e[t])){a+=e[t],t++,t<e.length&&("+"===e[t]||"-"===e[t])&&(a+=e[t],t++);const s=t;for(;t<e.length&&A(e[t]);)a+=e[t],t++;if(t===s)throw new b("Invalid scientific notation: missing exponent digits",i)}return{type:p.NUMBER,value:a,position:i}}function j(e,i){let t=i,a="";for(a+=e[t],t++;t<e.length&&P(e[t]);)a+=e[t],t++;return{type:p.IDENTIFIER,value:a,position:i}}function T(e,i){const t=e.substring(i).match(/^type\((u?int)(\d+)?\)\.(max|min)/);if(!t)return null;const a=t[0],s="int"===t[1],n=t[2],l=t[3];let o;if(o=n?parseInt(n,10):256,o%8!=0||o<8||o>256)throw new b(`Invalid Solidity type: ${s?"int":"uint"}${o}. Supported types: uint8-uint256 (multiples of 8) and int8-int256 (multiples of 8).`,i);const r=`type(${`${s?"int":"uint"}${n||"256"}`}).${l}`;return{token:{type:p.TYPE_BOUND,value:r,position:i},endPosition:i+a.length}}function D(e){return" "===e||"\t"===e||"\n"===e||"\r"===e}function A(e){return e>="0"&&e<="9"}function L(e){return e>="a"&&e<="z"||e>="A"&&e<="Z"||"_"===e}function P(e){return L(e)||A(e)}class B{constructor(e){this.tokens=e,this.position=0}parse(){const e=this.parseExpression();if(this.currentToken().type!==p.EOF)throw new b(`Unexpected token: ${this.currentToken().value}`,this.currentToken().position);return e}parseExpression(){let e=this.parseTerm();for(;this.currentToken().type===p.PLUS||this.currentToken().type===p.MINUS;){const i=this.currentToken().type===p.PLUS?"+":"-";this.advance();const t=this.parseTerm();e={type:h.BINARY_OP,operator:i,left:e,right:t}}return e}parseTerm(){let e=this.parseExponentiation();for(;this.currentToken().type===p.MULTIPLY||this.currentToken().type===p.DIVIDE;){const i=this.currentToken().type===p.MULTIPLY?"*":"/";this.advance();const t=this.parseExponentiation();e={type:h.BINARY_OP,operator:i,left:e,right:t}}return e}parseExponentiation(){let e=this.parsePrimary();if(this.currentToken().type===p.POWER){this.advance();const i=this.parseExponentiation();e={type:h.EXPONENTIATION,base:e,exponent:i}}return e}parsePrimary(){const e=this.currentToken();if(e.type===p.NUMBER)return this.advance(),this.parseNumberLiteral(e.value);if(e.type===p.TYPE_BOUND)return this.advance(),this.parseTypeBound(e.value);if(e.type===p.IDENTIFIER)return this.advance(),{type:h.IDENTIFIER,name:e.value};if(e.type===p.LPAREN){this.advance();const e=this.parseExpression();if(this.currentToken().type!==p.RPAREN)throw new b("Expected closing parenthesis",this.currentToken().position);return this.advance(),e}throw new b(`Unexpected token: ${e.value||e.type}`,e.position)}parseNumberLiteral(e){try{if(e.toLowerCase().includes("e")){const[i,t]=e.toLowerCase().split("e");if("1"===i){const i=parseInt(t,10);if(isNaN(i))throw new b(`Invalid exponent in scale constant: ${e}`,this.position);if(i<0)throw new b(`Negative exponents in scale constants are not supported: ${e}`,this.position);const a=10n**BigInt(i);return{type:h.NUMBER_LITERAL,value:a,decimals:i}}const a=this.parseScientificNotation(e);return{type:h.NUMBER_LITERAL,value:a,decimals:0}}const i=BigInt(e);return{type:h.NUMBER_LITERAL,value:i,decimals:0}}catch(i){throw new b(`Invalid number: ${e}`,this.position)}}parseScientificNotation(e){const[i,t]=e.toLowerCase().split("e");if(!i||!t)throw new b(`Invalid scientific notation: ${e}`,this.position);const a=BigInt(i),s=parseInt(t,10);if(isNaN(s))throw new b(`Invalid exponent in scientific notation: ${e}`,this.position);if(s<0)throw new b(`Negative exponents in literals are not supported: ${e}. Use division instead.`,this.position);return a*10n**BigInt(s)}parseTypeBound(e){const i=e.match(/^type\((u?int)(\d+)?\)\.(max|min)$/);if(!i)throw new b(`Invalid type bound: ${e}`,this.position);const t="int"===i[1],a=i[2]||"256",s=i[3],n=parseInt(a,10),l=`${t?"int":"uint"}${a}`;let o;return o=t?"max"===s?2n**BigInt(n-1)-1n:-(2n**BigInt(n-1)):"max"===s?2n**BigInt(n)-1n:0n,{type:h.TYPE_BOUND_LITERAL,value:o,decimals:0,solidityType:l,bound:s}}currentToken(){return this.tokens[this.position]||this.tokens[this.tokens.length-1]}advance(){this.position<this.tokens.length-1&&this.position++}}function M(e){return new B(e).parse()}function U(e,i){return e+i}function V(e,i){if(e!==i)throw new N(e,i,"+");return e}function O(e,i){if(e!==i)throw new N(e,i,"-");return e}function F(e,i){if(i<0){return(e*10n**BigInt(-i)).toString()}if(0===i)return e.toString();const t=e<0n,a=(t?-e:e).toString().padStart(i+1,"0"),s=`${a.slice(0,-i)||"0"}.${a.slice(-i)}`;return t?`-${s}`:s}function $(e,i,t="floor"){const a=new Set,s=_(e,i,t,a),n=F(s.value,s.decimals),l=s.value;let o="0";if(s.divisionRemainder&&s.divisionDivisor&&void 0!==s.divisionResultDecimals){const e=function(e,i,t,a){if(0n===e)return"0";const s="floor"===a?e:-(i-e),n=s<0n,l=50,o=(n?-s:s)*10n**BigInt(l),r=F(o/i,l+t);return n?`-${r}`:r}(s.divisionRemainder,s.divisionDivisor,s.divisionResultDecimals,t);o=function(e){if(!e.includes("."))return e;let i=e.replace(/\.?0+$/,"");return i.endsWith(".")&&(i=i.slice(0,-1)),i}(e)}const r=0===s.decimals?function(e,i){if(0===i.size)return;for(const t of i){const i=t.match(/^(u?int)(\d+)$/);if(!i)continue;const a="int"===i[1],s=parseInt(i[2],10);let n,l;if(a?(n=-(2n**BigInt(s-1)),l=2n**BigInt(s-1)-1n):(n=0n,l=2n**BigInt(s)-1n),e>l){const i=W(e,s,a),n=i.toString();return{solidityType:t,kind:"overflow",wrappedValue:i,wrappedHuman:n}}if(e<n){const i=W(e,s,a),n=i.toString();return{solidityType:t,kind:"underflow",wrappedValue:i,wrappedHuman:n}}}return}(s.value,a):void 0;return{raw:s.value,decimals:s.decimals,human:n,solidity:l,roundingLoss:o,warning:r}}function _(e,i,t,a){switch(e.type){case h.NUMBER_LITERAL:return function(e){return{value:e.value,decimals:e.decimals}}(e);case h.TYPE_BOUND_LITERAL:return function(e,i){i&&i.add(e.solidityType);return{value:e.value,decimals:0}}(e,a);case h.IDENTIFIER:return function(e,i){const t=i.get(e.name);if(!t)throw new E(e.name);if(null===t.decimals||void 0===t.decimals)throw new R(e.name);if(t.decimals<0)throw new Error(`Variable "${e.name}" has negative decimals: ${t.decimals}. Variables must have decimals >= 0.`);return{value:t.value,decimals:t.decimals}}(e,i);case h.BINARY_OP:return function(e,i,t,a){if("+"===e.operator||"-"===e.operator){const s=_(e.left,i,t,a),n=_(e.right,i,t,a);let l=s,o=n;const r=e.left.type===h.NUMBER_LITERAL&&0===s.decimals,c=e.right.type===h.NUMBER_LITERAL&&0===n.decimals;return r&&n.decimals>0?l={...s,decimals:n.decimals}:c&&s.decimals>0&&(o={...n,decimals:s.decimals}),"+"===e.operator?{value:l.value+o.value,decimals:V(l.decimals,o.decimals)}:{value:l.value-o.value,decimals:O(l.decimals,o.decimals)}}const s=_(e.left,i,t,a),n=_(e.right,i,t,a);if("*"===e.operator)return{value:s.value*n.value,decimals:U(s.decimals,n.decimals)};if("/"===e.operator){if(0n===n.value)throw new k;const e=s.value%n.value;let i;i="floor"===t||0n===e?s.value/n.value:(s.value+n.value-1n)/n.value;const a=(l=s.decimals,o=n.decimals,l-o);return{value:i,decimals:a,divisionRemainder:0n!==e?e:void 0,divisionDivisor:0n!==e?n.value:void 0,divisionResultDecimals:0n!==e?a:void 0}}var l,o;throw new Error(`Unknown operator: ${e.operator}`)}(e,i,t,a);case h.EXPONENTIATION:return function(e,i,t,a){if(e.base.type!==h.NUMBER_LITERAL)throw new S("base must be literal 10");const s=e.base;if(10n!==s.value)throw new S(`base must be 10, got ${s.value}`);const n=_(e.exponent,i,t,a);if(0!==n.decimals)throw new S(`exponent must be dimensionless (decimals = 0), got decimals = ${n.decimals}`);const l=Number(n.value);if(!Number.isSafeInteger(l))throw new S(`exponent value too large: ${n.value}. Must fit in safe integer range.`);if(l<0)throw new S(`exponent must be non-negative, got ${l}`);return{value:10n**BigInt(l),decimals:l}}(e,i,t,a);default:throw new Error(`Unknown AST node type: ${e.type}`)}}function W(e,i,t){const a=2n**BigInt(i);if(t){let t=e%a;t<0n&&(t+=a);return t>=2n**BigInt(i-1)?t-a:t}{let i=e%a;return i<0n&&(i+=a),i}}function Y(e){try{const i=I(e);return function(e){const i=new Set;function t(e){if(e.type===h.IDENTIFIER)i.add(e.name);else if(e.type===h.BINARY_OP){const i=e;t(i.left),t(i.right)}else if(e.type===h.EXPONENTIATION){const i=e;t(i.base),t(i.exponent)}}return t(e),i}(M(i))}catch{return new Set}}const G=e.createContext(null);function q({children:i}){const[t,a]=e.useState(()=>{const e=localStorage.getItem("solcalc-theme");return"light"===e||"dark"===e?e:"dark"}),[s,n]=e.useState(""),[l,o]=e.useState("floor"),[r,c]=e.useState(new Map),[d,u]=e.useState(null),[p,m]=e.useState(null),[h,v]=e.useState(!1);e.useEffect(()=>{document.documentElement.setAttribute("data-theme",t),localStorage.setItem("solcalc-theme",t)},[t]);const x=e.useCallback(e=>{a(e)},[]),y=e.useCallback(e=>{n(e);const i=Y(e);c(e=>{const t=new Map(e);for(const a of t.keys())i.has(a)||t.delete(a);for(const a of i)t.has(a)||t.set(a,{name:a,value:"",decimals:""});return t})},[]),g=e.useCallback((e,i)=>{c(t=>{const a=new Map(t),s=a.get(e);return s&&a.set(e,{...s,value:i}),a})},[]),b=e.useCallback((e,i)=>{c(t=>{const a=new Map(t),s=a.get(e);return s&&a.set(e,{...s,decimals:i}),a})},[]),w=e.useCallback(()=>{v(!0),m(null),u(null);try{const e=new Map;for(const[t,a]of r){if(""===a.value)throw new Error(`Variable "${t}" is missing a value`);if(""===a.decimals)throw new Error(`Variable "${t}" is missing decimals`);const i=parseInt(a.decimals,10);if(isNaN(i)||i<0)throw new Error(`Variable "${t}" has invalid decimals: ${a.decimals}`);const s=parseFloat(a.value);if(isNaN(s))throw new Error(`Variable "${t}" has invalid value: ${a.value}`);const n=10**i,l=BigInt(Math.round(s*n));e.set(t,{name:t,value:l,decimals:i})}const i=function(e,i,t="floor"){return $(M(I(e)),i,t)}(s,e,l);u(i)}catch(e){e instanceof Error?m(e.message):m(String(e))}finally{v(!1)}},[s,r,l]);e.useEffect(()=>{if(!s)return u(null),void m(null);let e=!0;for(const t of r.values())if(""===t.value||""===t.decimals){e=!1;break}if(!e)return u(null),void m(null);const i=setTimeout(()=>{w()},300);return()=>clearTimeout(i)},[s,r,w]);const N={expression:s,roundingMode:l,variables:r,theme:t,result:d,error:p,isEvaluating:h,setExpression:y,setRoundingMode:o,setVariableValue:g,setVariableDecimals:b,setTheme:x,evaluate:w};return f.jsx(G.Provider,{value:N,children:i})}function H(){const i=e.useContext(G);if(!i)throw new Error("useCalculator must be used within CalculatorProvider");return i}function X({onGuideClick:e}){const{roundingMode:i,setRoundingMode:t}=H();return f.jsx("div",{className:"toolbar",children:f.jsxs("div",{className:"toolbar-controls",children:[f.jsxs("label",{children:["Rounding",f.jsxs("select",{value:i,onChange:e=>t(e.target.value),children:[f.jsx("option",{value:"floor",children:"Floor"}),f.jsx("option",{value:"ceil",children:"Ceil"})]})]}),f.jsx("button",{className:"guide-button",onClick:e,title:"Open SolCalc Guidelines",children:"Guide ?"})]})})}function z(){const{expression:e,setExpression:i}=H();return f.jsxs("div",{className:"expression-section",children:[f.jsx("div",{className:"expression-header",children:f.jsx("label",{htmlFor:"expression",children:"Expression"})}),f.jsx("textarea",{id:"expression",className:"expression-input mono",value:e,onChange:e=>i(e.target.value),placeholder:"Enter expression (e.g., amount * price / 1e18)",rows:3,spellCheck:!1})]})}function Z(){const{variables:e,setVariableValue:i,setVariableDecimals:t}=H(),a=Array.from(e.values());return 0===a.length?null:f.jsxs("div",{className:"variables-section",children:[f.jsx("div",{className:"variables-header",children:f.jsx("span",{children:"Variables"})}),f.jsx("div",{className:"variables-list",children:a.map(e=>f.jsxs("div",{className:"variable-row",children:[f.jsx("div",{className:"variable-name mono",children:e.name}),f.jsx("input",{type:"text",className:"variable-value mono",value:e.value,onChange:t=>i(e.name,t.target.value),placeholder:"value"}),f.jsxs("label",{className:"variable-decimals-label text-secondary",children:["dec",f.jsx("input",{type:"number",className:"variable-decimals mono",value:e.decimals,onChange:i=>t(e.name,i.target.value),placeholder:"--",min:"0"})]})]},e.name))})]})}function K(){var e;const{result:i,error:t}=H();if(t)return f.jsxs("div",{className:"results-section",children:[f.jsx("div",{className:"results-label",children:"Error"}),f.jsx("div",{className:"results-output",children:f.jsx("div",{className:"result-error text-error",children:t})})]});if(!i)return null;const a=void 0!==i.warning,s=0===i.decimals&&a;return f.jsxs("div",{className:"results-section",children:[f.jsx("div",{className:"results-label",children:"Result"}),f.jsx("div",{className:"results-output mono "+(a?"results-overflow":""),children:s?f.jsxs(f.Fragment,{children:[f.jsxs("div",{className:"result-line",children:[f.jsx("span",{className:"result-key",children:"Value:"}),f.jsx("span",{className:"result-value",children:i.raw.toString()})]}),i.warning&&f.jsxs("div",{className:"result-line",children:[f.jsx("span",{className:"result-key",children:"Type:"}),f.jsx("span",{className:"result-value",children:i.warning.solidityType})]}),f.jsxs("div",{className:"result-line text-secondary",children:[f.jsx("span",{className:"result-key",children:"Decimals:"}),f.jsx("span",{className:"result-value",children:i.decimals})]})]}):f.jsxs(f.Fragment,{children:[f.jsxs("div",{className:"result-line",children:[f.jsx("span",{className:"result-key",children:"Raw:"}),f.jsx("span",{className:"result-value",children:i.raw.toString()})]}),f.jsxs("div",{className:"result-line",children:[f.jsx("span",{className:"result-key",children:"Human:"}),f.jsx("span",{className:"result-value",children:i.human})]}),f.jsxs("div",{className:"result-line",children:[f.jsx("span",{className:"result-key",children:"Solidity:"}),f.jsx("span",{className:"result-value",children:i.solidity.toString()})]}),f.jsxs("div",{className:"result-line",children:[f.jsx("span",{className:"result-key",children:"Loss:"}),f.jsx("span",{className:"result-value",children:i.roundingLoss})]}),f.jsxs("div",{className:"result-line text-secondary",children:[f.jsx("span",{className:"result-key",children:"Decimals:"}),f.jsx("span",{className:"result-value",children:i.decimals})]})]})}),i.warning&&f.jsxs("div",{className:"overflow-panel",children:[f.jsxs("div",{className:"overflow-warning",children:[f.jsx("span",{className:"overflow-icon",children:"⚠️"}),f.jsxs("span",{children:["Arithmetic ",i.warning.kind," detected in ",i.warning.solidityType," — computation exceeds the ","overflow"===i.warning.kind?"maximum":"minimum"," value representable by ",i.warning.solidityType,". Solidity arithmetic wraps modulo 2^",(null==(e=i.warning.solidityType.match(/\d+/))?void 0:e[0])||"256","."]})]}),f.jsxs("div",{className:"overflow-wrapped",children:[f.jsx("span",{className:"overflow-wrapped-label",children:"Wrapped Solidity Result:"}),f.jsx("span",{className:"overflow-wrapped-value mono",children:i.warning.wrappedHuman})]})]})]})}function J(){const{evaluate:e,isEvaluating:i}=H();return f.jsxs("div",{className:"footer-container",children:[f.jsxs("div",{className:"footer",children:[f.jsxs("div",{className:"footer-status",children:[f.jsx("span",{className:"status-indicator"}),f.jsx("span",{className:"text-secondary",children:"Auto-evaluating"})]}),f.jsx("button",{className:"evaluate-button primary",onClick:e,disabled:i,children:"Evaluate ↵"})]}),f.jsx("div",{className:"footer-credit",children:f.jsxs("span",{className:"text-secondary",children:["Created by"," ",f.jsx("a",{href:"https://x.com/32bits_Toby",target:"_blank",rel:"noopener noreferrer",className:"credit-link",children:"32bits-toby"})]})})]})}const Q=[{id:"getting-started",title:"Getting Started",guidelines:[{id:"gs-1",title:"What is SolCalc?",rule:"SolCalc is a mixed-decimal calculator that mimics Solidity's integer-only arithmetic with explicit decimal tracking.",explanation:"Solidity does not have floating-point types. All token amounts are stored as integers with an implied decimal place. For example, 1 USDC (6 decimals) is stored as 1000000. SolCalc helps you verify calculations across different decimal precisions without manual conversion.",examples:[{code:"1000000 with 6 decimals → 1.0 USDC",label:"USDC representation"},{code:"1000000000000000000 with 18 decimals → 1.0 ETH",label:"ETH representation"}],auditRelevance:"Understanding fixed-point representation is fundamental to auditing DeFi protocols. Misunderstanding decimal places is a common source of critical vulnerabilities."},{id:"gs-2",title:"Human-Readable Input",rule:'When you enter a value like "2" with decimals "18", SolCalc automatically converts it to 2000000000000000000.',explanation:'You don\'t need to type out the full integer representation. Enter the human-readable value (e.g., "2.5") and specify the decimal precision. SolCalc handles the conversion to the underlying integer.',examples:[{code:"Input: value=2, decimals=18 → 2000000000000000000",label:"Simple conversion"},{code:"Input: value=1.5, decimals=6 → 1500000",label:"USDC amount"}],auditRelevance:"This mirrors how users think about token amounts (human terms) vs. how contracts store them (integer terms). Auditors must verify conversions happen correctly."},{id:"gs-3",title:"Variables vs. Literals",rule:"Variables are defined explicitly with a value and decimal precision. Literals in expressions inherit decimals from context.",explanation:'Variables like "x" require you to specify both value and decimals. Scalar literals (plain integers like "1" or "100") automatically adapt to match the decimal precision of other operands in addition/subtraction.',examples:[{code:"x = 1000000000000000000 (18 decimals)\n1e18 + 1 → auto-lifts 1 to 18 decimals",label:"Scalar auto-lifting"},{code:"x + y requires x.decimals == y.decimals",label:"Variable constraint"}],auditRelevance:"Incorrect decimal assumptions cause precision loss bugs. Verify that scalar constants are scaled correctly in contract code."},{id:"gs-4",title:"Rounding Modes",rule:"SolCalc supports Floor (round down) and Ceil (round up) rounding modes, matching Solidity's division behavior.",explanation:"Solidity's native division always rounds down (floor). Many DeFi protocols implement custom ceil division for fair rounding. SolCalc shows both results and the precision loss.",examples:[{code:"7 / 2 (Floor) → 3, Loss: 0.5",label:"Floor mode"},{code:"7 / 2 (Ceil) → 4, Loss: -0.5",label:"Ceil mode"}],auditRelevance:"Rounding direction determines who loses value in divisions. Floor favors the protocol (user loses dust). Ceil favors the user (protocol loses dust). Verify which is intended."}]},{id:"core-decimal-rules",title:"Core Decimal Rules",guidelines:[{id:"cdr-1",title:"Multiplication Adds Decimals",rule:"When you multiply two values, their decimal precisions add together.",explanation:"Multiplying (a × 10^d1) by (b × 10^d2) gives (a×b × 10^(d1+d2)). This is fundamental to fixed-point arithmetic. You often need to scale down afterward.",examples:[{code:"(2 * 1e18) * (3 * 1e18) → 6 * 1e36",label:"Decimals add: 18 + 18 = 36"},{code:"price (6 decimals) * amount (18 decimals) → 24 decimals",label:"Mixed decimals"}],auditRelevance:"Forgetting to scale down after multiplication is a classic bug. Result may overflow or have wrong precision. Always verify the scaling factor matches the intended output decimals."},{id:"cdr-2",title:"Division Subtracts Decimals",rule:"When you divide two values, the result's decimals = numerator decimals - denominator decimals.",explanation:"Dividing (a × 10^d1) by (b × 10^d2) gives (a/b × 10^(d1-d2)). If the denominator has more decimals than the numerator, the result will have negative conceptual decimals (very small number).",examples:[{code:"(6 * 1e36) / (3 * 1e18) → 2 * 1e18",label:"Decimals subtract: 36 - 18 = 18"},{code:"(amount * price) / 1e18 → scales back to token decimals",label:"Common pattern"}],auditRelevance:"Division without proper scaling causes precision loss. Verify that divisions scale numerator up before dividing (multiply by precision factor first) to preserve significant digits."},{id:"cdr-3",title:"Addition/Subtraction Requires Matching Decimals",rule:"You can only add or subtract values with the same decimal precision (except scalar literals).",explanation:"Adding 1 ETH (18 decimals) to 1 USDC (6 decimals) is meaningless without conversion. SolCalc enforces this constraint to prevent logic errors.",examples:[{code:"(2 * 1e18) + (3 * 1e18) → 5 * 1e18 ✓",label:"Valid: same decimals"},{code:"(2 * 1e18) + (3 * 1e6) → Error ✗",label:"Invalid: mismatched decimals"}],auditRelevance:"Mismatched decimal addition is a critical bug. Always verify that operands are scaled to the same precision before addition/subtraction. Check for missing conversions."},{id:"cdr-4",title:"Scalar Literal Auto-Lifting",rule:'Plain integer literals (like "1" or "100") automatically adopt the decimal precision of the other operand in addition/subtraction.',explanation:'This makes expressions like "1e18 + 1" work intuitively (adding 1 wei, not 1 token). Only applies to literals, not variables. Only applies to +/- operations.',examples:[{code:"1e18 + 1 → (1 * 1e18) + (1 * 1e18) = 2 * 1e18",label:"Auto-lift: 1 becomes 1e18"},{code:"x + 1 where x has 6 decimals → 1 becomes 1e6",label:"Adapts to variable decimals"}],auditRelevance:"Contracts often add small constants (fees, dust). Verify that these constants are scaled correctly. SolCalc's auto-lifting mirrors Solidity's implicit casting behavior."},{id:"cdr-5",title:"Variables Do NOT Auto-Lift",rule:"Variables defined with explicit decimals never auto-lift, even in addition/subtraction.",explanation:"Auto-lifting only applies to literals. If you define x=1 (6 decimals) and y=1 (18 decimals), you cannot add them. This prevents accidental mismatches.",examples:[{code:"x (6 decimals) + y (18 decimals) → Error ✗",label:"Variables must match"},{code:"x + 1 (where x has 6 decimals) → 1 auto-lifts to 6 decimals ✓",label:"Literal adapts"}],auditRelevance:"Contracts must explicitly convert variables to matching decimals. Look for missing scaling multiplications when different token types interact."}]},{id:"powers-scaling",title:"Powers & Scaling",guidelines:[{id:"ps-1",title:"Scale Constants (1e18, 1e6)",rule:'1e18 is a scale constant representing "1.0 with 18 decimal places" (value = 10^18, decimals = 18).',explanation:"In Solidity, 1e18 is shorthand for 1000000000000000000. SolCalc treats this as a properly-scaled fixed-point number, not as scientific notation.",examples:[{code:"1e18 → value=1000000000000000000, decimals=18",label:"WAD constant"},{code:"1e6 → value=1000000, decimals=6",label:"USDC scale"}],auditRelevance:"Scale constants are used everywhere in DeFi. Verify that divisions by 1e18 correctly de-scale results. Missing or double-scaling causes magnitude errors."},{id:"ps-2",title:"Dynamic Exponentiation (10 ** n)",rule:"10 ** n produces a scale constant where n must be a dimensionless integer (decimals = 0).",explanation:"Allows computing scale factors dynamically, e.g., 10 ** tokenDecimals. The exponent must be a pure integer with no fractional part.",examples:[{code:"10 ** 18 → same as 1e18",label:"Static exponent"},{code:"10 ** (decimals - 6) → dynamic scaling",label:"Variable exponent"}],auditRelevance:"Dynamic scaling is common when handling multiple token types. Verify that exponent calculations are correct and that the base is always 10."},{id:"ps-3",title:"Only Base-10 Exponentiation",rule:"SolCalc only supports 10 ** n. Other bases (2 ** n, x ** y) are not allowed.",explanation:"Restricting to base-10 prevents ambiguity in decimal tracking. General exponentiation would require complex decimal inference rules.",examples:[{code:"10 ** 18 → Allowed ✓",label:"Base-10"},{code:"2 ** 256 → Not Allowed ✗",label:"Other base"}],auditRelevance:"Contracts rarely use non-base-10 exponentiation for financial calculations. If you see x ** y, verify it's not a decimal-scaled value being exponentiated."},{id:"ps-4",title:"Scaling Down After Multiplication",rule:"After multiplying two scaled values, divide by the scale constant to restore original precision.",explanation:'Multiplying two 18-decimal values gives 36 decimals. You must divide by 1e18 to get back to 18 decimals. This is the "mul-div" pattern.',examples:[{code:"(a * b) / 1e18 → restore to 18 decimals",label:"Standard WAD math"},{code:"(price * amount) / 1e18 → token amount",label:"Price calculation"}],auditRelevance:"Forgetting to scale down causes overflow or wrong magnitude. Verify every multiplication is followed by appropriate division."}]},{id:"rounding-loss",title:"Rounding & Loss",guidelines:[{id:"rl-1",title:"Floor Division (Round Down)",rule:"Floor mode rounds division results down to the nearest integer, matching Solidity's native / operator.",explanation:"When 7 / 2, the exact result is 3.5. Floor gives 3 (discards the 0.5). The user loses the fractional part.",examples:[{code:"7 / 2 (Floor) → 3",label:"Rounds down"},{code:"(3 * 1e18) / 7 (Floor) → Loss: ~0.428 tokens",label:"Positive loss (user loses)"}],auditRelevance:"Floor division favors the protocol at the user's expense. Verify this is intentional. Repeated floor divisions can accumulate significant loss for users."},{id:"rl-2",title:"Ceil Division (Round Up)",rule:"Ceil mode rounds division results up to the nearest integer, often implemented in DeFi for fairness.",explanation:"When 7 / 2, Ceil gives 4 (adds the missing 0.5). The protocol loses the fractional part to favor the user.",examples:[{code:"7 / 2 (Ceil) → 4",label:"Rounds up"},{code:"(3 * 1e18) / 7 (Ceil) → Loss: ~-0.428 tokens",label:"Negative loss (protocol loses)"}],auditRelevance:"Ceil is used in borrowing/lending to ensure users always get slightly more. Verify ceil is implemented correctly: (a + b - 1) / b. Check for off-by-one errors."},{id:"rl-3",title:"Loss = Exact - Result",rule:"Loss shows the difference between the mathematically exact result and the rounded result, displayed in the output's decimal precision.",explanation:"Positive loss means the user loses value (floor). Negative loss means the protocol loses value (ceil). Loss is scaled to the result's decimals for easy interpretation.",examples:[{code:"7 / 2 = 3.5 exactly\n7 / 2 (Floor) = 3, Loss = +0.5",label:"User loses 0.5"},{code:"7 / 2 (Ceil) = 4, Loss = -0.5",label:"Protocol loses 0.5"}],auditRelevance:"Large loss values indicate significant precision loss. Verify that loss is acceptable for the use case. Check if rounding is done before or after scaling."},{id:"rl-4",title:"Loss is Always Per-Operation",rule:"Loss is calculated and displayed for each division operation independently, not accumulated across the expression.",explanation:"SolCalc shows the loss from the final division in a complex expression. If there are multiple divisions, only the last one contributes to the displayed loss.",examples:[{code:"(a / b) / c → only shows loss from (result / c)",label:"Last division"},{code:"a / (b / c) → shows loss from (a / result)",label:"Outer division"}],auditRelevance:"Multiple divisions compound precision loss. Manually verify intermediate losses if accuracy is critical. Consider reordering operations to minimize loss."},{id:"rl-5",title:"Zero Loss Means Exact Division",rule:"If Loss is 0 (or not shown), the division was exact with no remainder.",explanation:"When the numerator is perfectly divisible by the denominator, there is no rounding and no loss. Floor and Ceil produce identical results.",examples:[{code:"8 / 2 → 4 (exact), Loss: 0",label:"No remainder"},{code:"(6 * 1e18) / (2 * 1e18) → 3 * 1e0 (exact)",label:"Clean division"}],auditRelevance:"Exact divisions are ideal. When auditing, check if the contract assumes exact division where it may not hold (e.g., user-provided inputs)."}]},{id:"variables-literals",title:"Variables & Literals",guidelines:[{id:"vl-1",title:"Defining Variables",rule:"Variables must have both a value and a decimal precision explicitly defined before evaluation.",explanation:"SolCalc auto-detects variables in your expression and prompts you to provide their values and decimals. This simulates passing token amounts into a function.",examples:[{code:"Expression: x * y / 1e18\nDefine: x=2 (18 decimals), y=3 (18 decimals)",label:"Variable definition"}],auditRelevance:"In contracts, verify that all variables have defined types and decimal handling. Missing decimal validation is a common vulnerability."},{id:"vl-2",title:"Variable Names",rule:"Variable names must start with a letter and contain only letters, numbers, and underscores.",explanation:"Follows standard identifier rules. Case-sensitive (x and X are different variables).",examples:[{code:"Valid: amount, price_usd, token1",label:"Valid names"},{code:"Invalid: 1amount, price-usd, token$",label:"Invalid names"}],auditRelevance:"Identifier naming in contracts should be clear and unambiguous. Watch for similar-looking names that could cause confusion (e.g., decimals vs _decimals)."},{id:"vl-3",title:"Integer Literals",rule:"Plain integers (1, 100, 500) are scalar literals with decimals=0 unless auto-lifted in +/- operations.",explanation:"Scalar literals are dimensionless constants. They adapt to context in addition/subtraction but remain decimals=0 in multiplication/division.",examples:[{code:"100 * 1e18 → 100 * 1e18 (no auto-lift)",label:"Multiplication: no lift"},{code:"1e18 + 100 → auto-lift 100 to 1e18",label:"Addition: auto-lift"}],auditRelevance:"Verify that integer constants in contracts are scaled appropriately for their context. Unscaled constants in multiplication cause magnitude errors."},{id:"vl-4",title:"Scientific Notation Literals",rule:"1e18, 2.5e6, etc. are scale constants with value and decimals derived from the notation.",explanation:"SolCalc parses 1e18 as {value: 10^18, decimals: 18}. Fractional mantissas like 2.5e6 become {value: 2.5 × 10^6, decimals: 6}.",examples:[{code:"1e18 → {value: 10^18, decimals: 18}",label:"Unit scale"},{code:"2.5e6 → {value: 2500000, decimals: 6}",label:"Fractional mantissa"}],auditRelevance:"Scale constants are foundational to DeFi. Verify that all scale factors match the intended token decimals (e.g., USDC uses 1e6, not 1e18)."}]},{id:"defi-patterns",title:"Common DeFi Patterns",guidelines:[{id:"dp-1",title:"Shares to Assets Conversion",rule:"shares * totalAssets / totalShares gives the asset amount for a given share amount.",explanation:"Vault shares represent proportional ownership. Convert shares to assets by multiplying by the exchange rate (totalAssets / totalShares). Must preserve decimals.",examples:[{code:"shares (18 decimals) * totalAssets (18 decimals) / totalShares (18 decimals) → 18 decimals",label:"ERC4626 pattern"}],auditRelevance:"Verify that shares and assets use consistent decimals. Check for rounding mode (floor favors vault, ceil favors user). Ensure no precision loss on small amounts."},{id:"dp-2",title:"Price * Amount Calculations",rule:"price * amount / 1e18 converts an amount to its value in another unit (e.g., tokens to USD).",explanation:"Prices are often stored with 18 decimals. Multiplying price by amount gives 36 decimals. Divide by 1e18 to scale back to 18 decimals.",examples:[{code:"(1500 * 1e18) * (10 * 1e18) / 1e18 → 15000 * 1e18",label:"ETH price * ETH amount"}],auditRelevance:"Verify the scaling factor matches the price decimals. Wrong scaling causes magnitude errors. Check for missing or double scaling."},{id:"dp-3",title:"Interest Accrual (Ray Math)",rule:"Interest rates often use 27 decimals (Ray) for precision. Multiply principal by rate, then divide by 1e27.",explanation:"Ray (10^27) provides extra precision for interest calculations. Common in lending protocols like Aave. Must scale down after multiplication.",examples:[{code:"principal (18 decimals) * rate (27 decimals) / 1e27 → 18 decimals",label:"Interest calculation"}],auditRelevance:"Verify Ray constants use 1e27, not 1e18. Mixing WAD (1e18) and RAY (1e27) causes critical errors. Check for consistent use of scale constants."},{id:"dp-4",title:"Basis Points (BPS)",rule:"Basis points (1 BPS = 0.01%) use 4 decimals. To apply a BPS fee: amount * bps / 10000.",explanation:"BPS is a standard for fees and percentages. 100 BPS = 1%. Multiply by BPS, divide by 10000 (not 1e18).",examples:[{code:"amount (18 decimals) * 250 (BPS) / 10000 → 2.5% fee",label:"250 BPS = 2.5%"}],auditRelevance:"Verify fee calculations use 10000, not 1e4 or 1e18. Check for missing scaling. Ensure BPS values are validated (max 10000 for 100%)."}]},{id:"limitations",title:"Limitations & Unsupported Features",guidelines:[{id:"lim-1",title:"No General Exponentiation",rule:"SolCalc does not support x ** y where x ≠ 10 or y is a decimal-scaled value.",explanation:"General exponentiation with decimal tracking is ambiguous. Restricting to 10 ** n keeps the tool focused on DeFi use cases.",examples:[{code:"10 ** 18 → Allowed ✓",label:"Base-10 allowed"},{code:"2 ** 256 → Not Allowed ✗",label:"Other bases not allowed"}],auditRelevance:"If a contract uses arbitrary exponentiation, verify it's not operating on decimal-scaled values. Exponentiation of scaled values causes exponential magnitude errors."},{id:"lim-2",title:"No Bitwise Operations",rule:"SolCalc does not support bitwise AND, OR, XOR, shifts, etc.",explanation:"Bitwise operations are low-level and not relevant to decimal arithmetic. Use a different tool for bitwise analysis.",examples:[{code:"x & y → Not Supported ✗",label:"Bitwise AND"},{code:"x << 2 → Not Supported ✗",label:"Bit shift"}],auditRelevance:"Bitwise operations in DeFi are rare. If present, verify they're not being applied to decimal-scaled values (which would corrupt the value)."},{id:"lim-3",title:"No Floating-Point Operations",rule:"SolCalc uses BigInt-only arithmetic. No floating-point math at any stage.",explanation:"Matches Solidity's integer-only behavior. All values are represented as scaled integers. Division truncates, no rounding to nearest.",examples:[{code:"7 / 2 → 3 (not 3.5)",label:"Integer division"}],auditRelevance:'Solidity has no float type. Any "decimal" math must be done via scaled integers. Verify contracts never rely on floating-point behavior.'},{id:"lim-4",title:"No Function Calls or Complex Expressions",rule:"SolCalc evaluates arithmetic expressions only. No function calls (sqrt, abs, min, max, etc.).",explanation:"Focused on basic arithmetic with decimal tracking. For complex math, break it into steps and evaluate each step separately.",examples:[{code:"sqrt(x) → Not Supported ✗",label:"Function call"},{code:"(x + y) * (a - b) → Supported ✓",label:"Arithmetic only"}],auditRelevance:"When auditing complex math libraries (e.g., sqrt for AMMs), verify each operation separately. Check that decimals are preserved across function boundaries."}]},{id:"audit-pitfalls",title:"Audit Pitfalls",guidelines:[{id:"ap-1",title:"Multiplication Before Division",rule:"Always multiply before dividing to preserve precision. a * b / c is better than a / c * b.",explanation:"Dividing first loses precision in the intermediate result. Multiplying first maximizes the numerator before truncation.",examples:[{code:"(1e18 * 3) / 7 → Loss: ~0.428",label:"Multiply first (better)"},{code:"(1e18 / 7) * 3 → Loss: ~1.285",label:"Divide first (worse)"}],auditRelevance:"Check operation order in contracts. Premature division causes excess precision loss. Verify the order maximizes numerator before division."},{id:"ap-2",title:"Verify Scale Factor Matches Output",rule:"After multiplication, the scale-down factor must match the desired output decimals.",explanation:"If you multiply two 18-decimal values and want 6-decimal output, divide by 1e30 (not 1e18). The scale factor depends on both input and output decimals.",examples:[{code:"(a * b) / 1e18 → 18-decimal output",label:"Standard WAD"},{code:"(a * b) / 1e30 → 6-decimal output",label:"Custom scaling"}],auditRelevance:"Mismatched scale factors are a common bug. Verify the divisor is computed correctly based on input and output decimals. Check for hardcoded scale constants."},{id:"ap-3",title:"Check Decimal Assumptions on External Calls",rule:"When calling external contracts, never assume decimal precision. Always query decimals() explicitly.",explanation:"Different tokens use different decimals (USDC=6, WETH=18, WBTC=8). Hardcoding 18 decimals causes magnitude errors for non-standard tokens.",examples:[{code:"USDC.decimals() → 6 (not 18!)",label:"Non-standard decimals"}],auditRelevance:"Check if the contract queries decimals() or assumes 18. Assuming 18 for USDC causes 10^12 magnitude error. Verify all token interactions handle variable decimals."},{id:"ap-4",title:"Repeated Division Compounds Loss",rule:"Each division operation truncates. Multiple divisions compound the loss. Combine divisions when possible.",explanation:"(a / b) / c loses more precision than a / (b * c). Combine denominators to minimize rounding operations.",examples:[{code:"a / b / c → Two truncations",label:"Compounded loss"},{code:"a / (b * c) → One truncation",label:"Reduced loss"}],auditRelevance:"Look for sequential divisions in contracts. Verify if they can be combined. Check if accumulated loss is acceptable for the use case."}]},{id:"type-bounds",title:"Solidity Type Bounds",guidelines:[{id:"tb-1",title:"Type Bounds Are Scalars",rule:"type(uintX).max, type(uintX).min, type(intX).max, and type(intX).min are scalar values with decimals = 0.",explanation:"Solidity type bounds represent the mathematical limits of integer types, not token amounts. They are dimensionless scalars used for overflow checks and sentinel values.",examples:[{code:"type(uint256).max → 2^256 - 1 (decimals: 0)",label:"Maximum unsigned value"},{code:"type(int128).min → -2^127 (decimals: 0)",label:"Minimum signed value"},{code:"type(uint8).max → 255",label:"Small type bound"}],auditRelevance:"Type bounds are used for overflow checks, caps, and sentinel values. Verify they are never mixed with scaled token amounts without proper conversion."},{id:"tb-2",title:"Supported Type Ranges",rule:"SolCalc supports all Solidity integer types: uint8 through uint256 and int8 through int256 (multiples of 8).",explanation:"uint = uint256 and int = int256 are aliases. Unsigned types range from 0 to 2^N - 1. Signed types range from -2^(N-1) to 2^(N-1) - 1.",examples:[{code:"uint8: 0 to 255",label:"8-bit unsigned"},{code:"uint256: 0 to 2^256 - 1",label:"256-bit unsigned"},{code:"int8: -128 to 127",label:"8-bit signed"},{code:"int256: -2^255 to 2^255 - 1",label:"256-bit signed"}],auditRelevance:"Verify contracts use appropriate type sizes. Smaller types (uint8, uint64) can save gas but increase overflow risk. uint256 is the safest default."},{id:"tb-3",title:"Overflow Detection and Wrapping",rule:"Overflow detection only applies to pure scalar results (decimals = 0). When arithmetic on type bounds exceeds the type's range, SolCalc shows both the unbounded result and the wrapped Solidity value.",explanation:"SolCalc computes using unbounded math (no overflow), then checks if the result would overflow in Solidity. Overflow warnings are only shown when the final result has decimals = 0, since Solidity integer types are always scalars. Fixed-point results (decimals > 0) don't trigger overflow warnings.",examples:[{code:"type(uint256).max + 1 → Unbounded result + wrap preview",label:"Overflow detected (scalar)"},{code:"type(uint256).max + 3 → Wraps to 2",label:"Modulo 2^256"},{code:"type(uint256).max / 1e18 → No overflow warning",label:"Fixed-point result (no warning)"},{code:"(type(uint256).max + 1) * 1e18 / 1e18 → Overflow detected",label:"Decimals cancel to 0"}],auditRelevance:"In unchecked blocks, Solidity arithmetic wraps silently. SolCalc helps auditors reason about overflow behavior without executing contracts. Verify wrapping is intentional. Note that overflow only matters for pure integer operations."},{id:"tb-4",title:"Common Audit Patterns",rule:"Type bounds are used for caps, overflow checks, and sentinel values. Verify these patterns are implemented correctly.",explanation:"Protocols use type(uintX).max for unlimited approvals, caps on user inputs, and sentinel values. Auditors must verify these don't create vulnerabilities.",examples:[{code:"require(amount <= type(uint256).max / 1e18)",label:"Prevent overflow after scaling"},{code:"if (allowance == type(uint256).max) return;",label:"Unlimited approval check"},{code:"uint256 cap = type(uint128).max;",label:"Safe cap for downcasting"}],auditRelevance:"Verify overflow checks are correct. Ensure sentinel values (like max approval) don't bypass critical logic. Check downcasting doesn't silently truncate values."}]},{id:"advanced",title:"Advanced / Audit-Grade",guidelines:[{id:"adv-1",title:"Overflow Behavior in Solidity",rule:"Solidity 0.8+ reverts on overflow by default. In unchecked blocks, arithmetic wraps modulo 2^256 (or the type size).",explanation:"Before Solidity 0.8, arithmetic could silently overflow. Modern Solidity reverts unless wrapped in an unchecked{} block. SolCalc shows what the wrapped value would be.",examples:[{code:"type(uint256).max + 1 → Reverts (Solidity 0.8+)",label:"Checked overflow"},{code:"unchecked { type(uint256).max + 1 } → Wraps to 0",label:"Unchecked overflow"}],auditRelevance:"For Solidity <0.8, verify SafeMath is used. For 0.8+, verify unchecked blocks are intentional and safe. Use SolCalc to preview overflow behavior before it happens on-chain."},{id:"adv-2",title:"Gas-Optimal Rounding",rule:"Ceil division in Solidity uses (a + b - 1) / b to avoid expensive modulo operations.",explanation:"Computing the remainder with a % b costs gas. The formula (a + b - 1) / b achieves ceil without remainder calculation.",examples:[{code:"(a + b - 1) / b → Ceil without modulo",label:"Gas-optimized ceil"}],auditRelevance:"Verify ceil implementations use this pattern. Check for edge case: a + b - 1 could overflow if a is near type(uint256).max. Ensure bounds are validated."},{id:"adv-3",title:"Negative Values and Signed Arithmetic",rule:"SolCalc supports negative intermediate values (for loss calculation), but Solidity contracts must handle signed types carefully.",explanation:"Solidity has int256 for signed values. Mixing uint and int requires explicit casting. Underflows (e.g., uint256 a - b where b > a) revert.",examples:[{code:"int256 loss = int256(exact) - int256(rounded)",label:"Signed loss calculation"}],auditRelevance:"Verify that contracts use appropriate types (uint vs int). Check for unsafe casts that could cause unexpected behavior. Test boundary cases with negative values."},{id:"adv-4",title:"Precision Loss is Unavoidable",rule:"Integer division always loses precision unless exact. Design protocols to tolerate small rounding losses.",explanation:"No amount of clever math can eliminate truncation in integer division. The best you can do is minimize loss and choose the rounding direction intentionally.",examples:[{code:"(1e18 * 1) / 3 → Loss: ~0.333 tokens",label:"Unavoidable loss"}],auditRelevance:"Ensure the protocol design accounts for rounding loss. Verify that accumulated dust is handled (e.g., donating to reserves, burning, etc.). Check that loss doesn't break invariants."}]}];function ee({isOpen:i,onClose:t}){const[a,s]=e.useState("index"),[n,l]=e.useState(null),o=()=>{s("index"),l(null),t()};return i?f.jsx("div",{className:"guideline-overlay",onClick:o,children:f.jsxs("div",{className:"guideline-panel",onClick:e=>e.stopPropagation(),children:[f.jsxs("div",{className:"guideline-header",children:[f.jsx("h2",{children:"SolCalc Guidelines"}),f.jsx("button",{className:"guideline-close",onClick:o,"aria-label":"Close guidelines",children:"×"})]}),f.jsxs("div",{className:"guideline-content",children:["index"===a&&f.jsx(ie,{onGuidelineClick:e=>{l(e),s("content")}}),"content"===a&&n&&f.jsx(te,{guideline:n,onBack:()=>{s("index"),l(null)}})]})]})}):null}function ie({onGuidelineClick:e}){return f.jsx("div",{className:"guideline-index",children:Q.map(i=>f.jsxs("div",{className:"guideline-section",children:[f.jsx("h3",{className:"section-title",children:i.title}),f.jsx("ul",{className:"guideline-list",children:i.guidelines.map(i=>f.jsx("li",{children:f.jsxs("button",{className:"guideline-item",onClick:()=>e(i),children:[f.jsx("span",{className:"guideline-item-title",children:i.title}),f.jsx("span",{className:"guideline-item-arrow",children:"→"})]})},i.id))})]},i.id))})}function te({guideline:e,onBack:i}){return f.jsxs("div",{className:"guideline-detail",children:[f.jsx("button",{className:"guideline-back",onClick:i,children:"← Back to Guidelines"}),f.jsxs("div",{className:"guideline-detail-content",children:[f.jsx("h3",{className:"guideline-detail-title",children:e.title}),f.jsxs("div",{className:"guideline-section-block",children:[f.jsx("h4",{children:"Rule"}),f.jsx("p",{children:e.rule})]}),f.jsxs("div",{className:"guideline-section-block",children:[f.jsx("h4",{children:"Explanation"}),f.jsx("p",{children:e.explanation})]}),f.jsxs("div",{className:"guideline-section-block",children:[f.jsx("h4",{children:"Examples"}),e.examples.map((e,i)=>f.jsxs("div",{className:"guideline-example",children:[f.jsx("pre",{className:"example-code",children:e.code}),e.label&&f.jsx("p",{className:"example-label",children:e.label})]},i))]}),f.jsxs("div",{className:"guideline-section-block",children:[f.jsx("h4",{children:"Audit Relevance"}),f.jsx("p",{children:e.auditRelevance})]})]})]})}function ae(){const{theme:i,setTheme:t}=H(),[a,s]=e.useState(!1);return f.jsxs("div",{className:"app",children:[f.jsxs("header",{className:"app-header",children:[f.jsxs("div",{className:"app-branding",children:[f.jsx("div",{className:"app-icon",children:"🧮"}),f.jsxs("div",{className:"app-title",children:[f.jsx("h1",{children:"SolCalc"}),f.jsx("p",{className:"app-subtitle text-secondary",children:"Mixed-Decimal Calculator"})]})]}),f.jsx("button",{className:"theme-toggle",onClick:()=>{t("dark"===i?"light":"dark")},"aria-label":"Toggle theme",title:`Switch to ${"dark"===i?"light":"dark"} mode`,children:"dark"===i?"☀️":"🌙"})]}),f.jsx(X,{onGuideClick:()=>{s(!0)}}),f.jsx(z,{}),f.jsx(Z,{}),f.jsx(K,{}),f.jsx(J,{}),f.jsx(ee,{isOpen:a,onClose:()=>{s(!1)}})]})}function se(){return f.jsx(q,{children:f.jsx(ae,{})})}x.createRoot(document.getElementById("root")).render(f.jsx(t.StrictMode,{children:f.jsx(se,{})}));
//# sourceMappingURL=index-DWs3Yk0_.js.map
